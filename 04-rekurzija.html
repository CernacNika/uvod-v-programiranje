<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Rekurzija &mdash; Python za matematike 0.1 documentation</title>
    
    <link rel="stylesheet" href="_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '0.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/translations.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="Python za matematike 0.1 documentation" href="index.html" />
    <link rel="prev" title="Funkcije" href="03-funkcije.html" />
   
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head>
  <body role="document">  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="rekurzija">
<h1>Rekurzija<a class="headerlink" href="#rekurzija" title="Povezava na naslov">¶</a></h1>
<p>Če za trenutek odmislimo, da od računalnikov pričakujemo tudi to, da kaj
preberejo s tipkovnice, kaj izrišejo na zaslon, ali pa se kaj pogovarjajo z
drugimi računalniki, lahko s tisto malega, kar smo spoznali v prejšnjem
poglavju, napišemo čisto vse, kar je računalnik sposoben izračunati. Tista
stvar, ki nam vse to omogoča je rekurzija.</p>
<div class="section" id="rekurzivni-klici">
<h2>Rekurzivni klici<a class="headerlink" href="#rekurzivni-klici" title="Povezava na naslov">¶</a></h2>
<p>Videli smo, da lahko iz funkcij kličemo tudi druge funkcije. Na primer, v
funkciji <code class="docutils literal"><span class="pre">povrsina_tetraedra</span></code> smo poklicali funkcijo <code class="docutils literal"><span class="pre">ploscina_trikotnika</span></code>,
v tej pa vgrajeno funkcijo <code class="docutils literal"><span class="pre">math.sqrt</span></code>. V resnici pa lahko v funkciji
pokličemo tudi funkcijo samo. Takemu klicu pravimo <strong>rekurzivni klic</strong>.
Poglejmo, kako bi izračunali <span class="math">\(n! = n \cdot (n - 1) \dots 3 \cdot 2 \cdot
1\)</span>. Kot vidimo velja <span class="math">\(n! = n \cdot (n - 1)!\)</span>, zato bomo <span class="math">\(n!\)</span>
izračunali tako, da bomo <span class="math">\(n\)</span> pomnožili z <span class="math">\((n - 1)!\)</span>. Toda od kod
bomo dobili tega? Preprosto, <span class="math">\(n - 1\)</span> bomo pomnožili z <span class="math">\((n - 2)!\)</span>. Od
kod pa tega? Ja iz <span class="math">\((n - 3)!\)</span>. In tako naprej vse do <span class="math">\(2!\)</span>, ki ga
bomo dobili iz <span class="math">\(1!\)</span>, tega pa iz <span class="math">\(0!\)</span>, ki je po definiciji enak
<span class="math">\(1\)</span>.</p>
<p>Torej lahko funkcijo, ki računa fakulteto, napišemo tako, da najprej pogleda
svoj argument <code class="docutils literal"><span class="pre">n</span></code>. Če je enak 1, vrne 1, sicer pa izračunamo tako, da <code class="docutils literal"><span class="pre">n</span></code>
pomnožimo z rezultatom klica <code class="docutils literal"><span class="pre">fakulteta(n</span> <span class="pre">-</span> <span class="pre">1)</span></code>.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">fakulteta</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Vrne fakulteto naravnega števila n.&#39;&#39;&#39;</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">n</span> <span class="o">*</span> <span class="n">fakulteta</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">fakulteta</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fakulteta</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="go">120</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fakulteta</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="go">3628800</span>
</pre></div>
</div>
<p>Še en primer rekurzivne definicije so Fibonaccijeva števila. Velja <span class="math">\(F_0 = 0\)</span>,
<span class="math">\(F_1 = 1\)</span>, za vse <span class="math">\(n \ge 2\)</span> pa velja in <span class="math">\(F_{n} = F_{n - 1} + F_{n - 2}\)</span>.
Funkcijo tedaj napišemo podobno na podoben način kot zgornjo: če
je <code class="docutils literal"><span class="pre">n</span></code> enak 0, vrnemo 0, sicer pogledamo, ali je enak 1. V tem primeru vrnemo
1. Če pa tudi 1 ni enak, mora biti večji ali enak 2, zato se pokličemo
rekurzivno.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">fibonacci</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span>
    <span class="k">elif</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">fibonacci</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">fibonacci</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">fibonacci</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fibonacci</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fibonacci</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="go">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fibonacci</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>
<span class="go">6765</span>
</pre></div>
</div>
<p>Tudi ta funkcija ima še svoje težave, zato se je še ne naučite, vendar se bomo s
tem ukvarjali malo kasneje.</p>
</div>
<div class="section" id="evklidov-algoritem">
<h2>Evklidov algoritem<a class="headerlink" href="#evklidov-algoritem" title="Povezava na naslov">¶</a></h2>
<p>Zdaj pa je že čas, da si pogledamo še naš prvi pravi algoritem. Algoritem je
zaporedje korakov, s katerimi dobimo iskani rezultat. Načeloma lahko pod besedo
algoritem razumemo tudi zaporedje korakov, s katerimi si skuhamo jajca (vzemi
posodo, odpri pipo, postavi posodo pod pipo, ko je posoda dovolj polna, …),
ampak ponavadi si jo prihranimo za postopke, s katerimi izračunamo želene
vrednosti.</p>
<p>Za prvi algoritem se spodobi, da si pogledamo najstarejši znani algoritem in
sicer Evklidov algoritem za iskanje navečjega skupnega delitelja dveh števil.
Naj bo <span class="math">\(d\)</span> največji skupni delitelj števil <span class="math">\(m\)</span> in <span class="math">\(n\)</span>. Pišimo
<span class="math">\(m = k \cdot n + o\)</span>, kjer je <span class="math">\(0 \le o &lt; n\)</span>. Torej: <span class="math">\(o\)</span> je
ostanek pri deljenju števila <span class="math">\(m\)</span> z <span class="math">\(n\)</span>. Ker e <span class="math">\(d\)</span> deli <span class="math">\(n\)</span>,
deli tudi <span class="math">\(k \cdot n\)</span>. Poleg tega <span class="math">\(d\)</span> deli tudi <span class="math">\(m\)</span>, zato
deli tudi <span class="math">\(o = m - k \cdot n\)</span>. Velja tudi obratno, če <span class="math">\(d\)</span> deli
<span class="math">\(n\)</span> in <span class="math">\(o\)</span>, potem deli tudi <span class="math">\(m = k \cdot n + o\)</span>.</p>
<p>Zato lahko iskanje največjega skupnega delitelja števil <span class="math">\(m\)</span> in <span class="math">\(n\)</span>
prevedemo na iskanje največjega skupnega delitelja števil <span class="math">\(n\)</span> in
<span class="math">\(o\)</span>. Videti je, kot da se vrtimo v krogu, vendar se ne. Poglejmo, kaj
se zgodi:</p>
<ol class="arabic simple">
<li>Največji skupni delitelj števil <span class="math">\(456\)</span> in <span class="math">\(123\)</span> je enak
največjemu skupnemu delitelju števil <span class="math">\(123\)</span> in <span class="math">\(456 - 3 \cdot 123 = 87\)</span>.</li>
<li>Največji skupni delitelj števil <span class="math">\(123\)</span> in <span class="math">\(87\)</span> je enak
največjemu skupnemu delitelju števil <span class="math">\(87\)</span> in <span class="math">\(123 - 1 \cdot 87 = 36\)</span>.</li>
<li>Največji skupni delitelj števil <span class="math">\(87\)</span> in <span class="math">\(36\)</span> je enak
največjemu skupnemu delitelju števil <span class="math">\(36\)</span> in <span class="math">\(123 - 2 \cdot 36 = 15\)</span>.</li>
<li>Največji skupni delitelj števil <span class="math">\(36\)</span> in <span class="math">\(15\)</span> je enak
največjemu skupnemu delitelju števil <span class="math">\(15\)</span> in <span class="math">\(36 - 2 \cdot 15 = 6\)</span>.</li>
<li>Največji skupni delitelj števil <span class="math">\(15\)</span> in <span class="math">\(6\)</span> je enak
največjemu skupnemu delitelju števil <span class="math">\(6\)</span> in <span class="math">\(15 - 2 \cdot 6 = 3\)</span>.</li>
<li>Največji skupni delitelj števil <span class="math">\(6\)</span> in <span class="math">\(3\)</span> je enak
največjemu skupnemu delitelju števil <span class="math">\(3\)</span> in <span class="math">\(6 - 2 \cdot 3 = 0\)</span>.</li>
</ol>
<p>Postopka ne moremo več nadaljevati, ker ne moremo deliti z nič. Kaj pa je
največji skupni delitelj števil 3 in 0? Ja, 3 vendar. Torej, ko je drugo število
enako 0, je prvo število ravno njun največji skupni delitelj, po vseh prejšnjih
sklepih pa tudi največji skupni delitelj vseh prejšnjih parov vključno s prvim.</p>
<p>Evklidov algoritem je torej sledeč: če je <span class="math">\(n = 0\)</span>, potem je največji skupni
delitelj števil <span class="math">\(m\)</span> in <span class="math">\(n\)</span> enak kar <span class="math">\(m\)</span>, sicer pa je enak
največjemu skupnemu delitelju števil <span class="math">\(n\)</span> in <span class="math">\(o\)</span>, kjer je <span class="math">\(o\)</span>
ostanek pri deljenju <span class="math">\(m\)</span> z <span class="math">\(n\)</span>.
Ta postopek enostavno prevedemo v Python:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">gcd</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Vrne največji skupni delitelj števil m in n.&#39;&#39;&#39;</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">m</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">gcd</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span> <span class="o">%</span> <span class="n">n</span><span class="p">)</span>
</pre></div>
</div>
<p>Pri tem je <code class="docutils literal"><span class="pre">gcd</span></code> (<em>greatest common divisor</em>) običajna oznaka za največjega
skupnega delitelja.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">gcd</span><span class="p">(</span><span class="mi">456</span><span class="p">,</span> <span class="mi">123</span><span class="p">)</span>
<span class="go">3</span>
</pre></div>
</div>
<p>Algoritem deluje tudi, kadar je <span class="math">\(n &lt; m\)</span>, saj je v tem primeru
<span class="math">\(n = 0 \cdot m + n\)</span>, zato v naslednjem koraku njuni mesti zamenjamo in
nadaljujemo kot prej.</p>
</div>
<div class="section" id="iskanje-nicel-z-bisekcijo">
<h2>Iskanje ničel z bisekcijo<a class="headerlink" href="#iskanje-nicel-z-bisekcijo" title="Povezava na naslov">¶</a></h2>
<p>Poglejmo si še enostaven algoritem, s katerim lahko približno izračunamo ničlo
zvezne realne funkcije <span class="math">\(f\)</span> na intervalu <span class="math">\([a, b]\)</span>, če vemo, da sta
vrednosti <span class="math">\(f(a)\)</span> in <span class="math">\(f(b)\)</span> različno predznačeni.
Naj bo <span class="math">\(c = (a + b) / 2\)</span> sredina intervala.
Tedaj ločimo tri primere <span class="math">\(f(c)\)</span>:</p>
<ul class="simple">
<li>Če imamo srečo, je <span class="math">\(f(c) = 0\)</span>, zato smo našli ničlo in postopek lahko končamo.
Sicer je <span class="math">\(f(c)\)</span> neničelno število, zatorej ima nek predznak.</li>
<li>Če je predznak <span class="math">\(f(c)\)</span> različen od predznaka <span class="math">\(f(a)\)</span> lahko na podoben
način nadaljujemo z iskanjem ničle na intervalu <span class="math">\([a, c]\)</span>.</li>
<li>V nasprotnem primeru pa mora biti predznak <span class="math">\(f(c)\)</span> različen od predznaka
<span class="math">\(f(b)\)</span> (ker imata <span class="math">\(f(a)\)</span> in <span class="math">\(f(b)\)</span> različen predznak), zato
lahko z iskanjem nadaljujemo na intervalu <span class="math">\([c, b]\)</span>.</li>
</ul>
<p>Ker interval vedno razdelimo na pol, postopku pravimo <em>bisekcija</em>. Ker lahko
realna števila poljubno delimo, se zgornji postopek ne bo nikoli ustavil (razen,
če imamo srečo in naletimo točno na ničlo). Toda ker nas zanima le približek
ničle, lahko postopek ustavimo takrat, ko se krajišči intervala razlikujeta za
dovolj majhno vrednost <span class="math">\(\varepsilon\)</span>. Načeloma v algoritmu prvo možnost
(ko je <span class="math">\(f(c) = 0\)</span>) kar izpustimo, saj je preveč redka, pa tudi brez nje
algoritem najde pravo rešitev.</p>
<p>V Pythonu bi algoritem zapisali kot:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">bisekcija</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">eps</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Z metodo bisekcije izračuna ničlo f na intervalu [a, b].&#39;&#39;&#39;</span>
    <span class="n">c</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
    <span class="k">if</span> <span class="n">b</span> <span class="o">-</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="n">eps</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">c</span>
    <span class="k">elif</span> <span class="n">f</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">*</span> <span class="n">f</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">bisekcija</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">eps</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">bisekcija</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">eps</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">math</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bisekcija</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mf">0.01</span><span class="p">)</span>
<span class="go">3.14453125</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bisekcija</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mf">0.00001</span><span class="p">)</span>
<span class="go">3.141590118408203</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bisekcija</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">10</span> <span class="o">**</span> <span class="o">-</span><span class="mi">10</span><span class="p">)</span>
<span class="go">3.1415926536137704</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bisekcija</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mf">1e-10</span><span class="p">)</span>
<span class="go">3.1415926536137704</span>
</pre></div>
</div>
<p>V zadnjem klicu je <code class="docutils literal"><span class="pre">1e-10</span></code> krajši zapis za <span class="math">\(1 \cdot 10^{-10}\)</span>. V tem
zapisu plavajočih števil ločeno zapišemo decimalke (čemur rečemo <em>mantisa</em>),
nato pa še eksponent. Na primer <code class="docutils literal"><span class="pre">3.2445e2</span></code> je število <span class="math">\(324,45 = 3,2445 \cdot 10^2\)</span>)</p>
</div>
<div class="section" id="neobvezni-argumenti">
<h2>Neobvezni argumenti<a class="headerlink" href="#neobvezni-argumenti" title="Povezava na naslov">¶</a></h2>
<p>Včasih imamo za nekatere argumente funkcij v mislih že prav določeno vrednost.
Na primer, za izračun logaritma potrebujemo dve števili: osnovo in argument
(tudi logaritmand). Toda velikokrat za osnovo vzamemo <span class="math">\(10\)</span>, zato namesto
<span class="math">\(\log_{10} x\)</span> pišemo kar <span class="math">\(\log x\)</span>. Tudi pri Pythonu je podobno. Če
se nam ob klicu funkcije <code class="docutils literal"><span class="pre">bisekcija</span></code> ne da vedno znova navajati vrednosti
argumenta <code class="docutils literal"><span class="pre">eps</span></code>, lahko pišemo:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">bisekcija</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="mf">1e-10</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Z metodo bisekcije izračuna ničlo f na intervalu [a, b].&#39;&#39;&#39;</span>
    <span class="n">c</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
    <span class="k">if</span> <span class="n">b</span> <span class="o">-</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="n">eps</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">c</span>
    <span class="k">elif</span> <span class="n">f</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">*</span> <span class="n">f</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">bisekcija</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">eps</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">bisekcija</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">eps</span><span class="p">)</span>
</pre></div>
</div>
<p>Tedaj bo Python vsakič, ko bomo funkciji podali le tri argumente, za vrednost
argumenta <code class="docutils literal"><span class="pre">eps</span></code> vzel <code class="docutils literal"><span class="pre">1e-10</span></code>. Če pa želimo vrednost vseeno določiti, pa jo
lahko:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">math</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bisekcija</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="mf">1e-10</span><span class="p">)</span>
<span class="go">3.1415926536137704</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bisekcija</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="go">3.1415926536137704</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bisekcija</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="mf">0.01</span><span class="p">)</span>
<span class="go">3.14453125</span>
</pre></div>
</div>
<p>Klic deluje tudi, če neobveznih argumentov ne poimenujemo, vendar to vodi do
zmede.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">bisekcija</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mf">0.01</span><span class="p">)</span>
<span class="go">3.14453125</span>
</pre></div>
</div>
</div>
<div class="section" id="funkcije-visjega-reda">
<h2>Funkcije višjega reda<a class="headerlink" href="#funkcije-visjega-reda" title="Povezava na naslov">¶</a></h2>
<p>Zgoraj lahko opazimo, da nam Python dopušča, da za argumente funkcij ne podajamo
le števil, temveč tudi druge funkcije. Pravimo, da podpira <em>funkcije višjega
reda</em>. Če želimo, lahko za argumente podamo tudi funkcije, ki smo jih definirali
sami:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">moj_f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">2</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">bisekcija</span><span class="p">(</span><span class="n">moj_f</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mf">0.000001</span><span class="p">)</span>
<span class="go">1.4142136573791504</span>
</pre></div>
</div>
<p>Če se nam neke funkcije, ki bi jo uporabili samo v enem primeru (kot je ta zgoraj),
ne da poimenovati, lahko uporabimo <em>anonimne</em> oziroma <em>lambda</em> funkcije. Zgornji
primer bi z njimi pisali kot:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">bisekcija</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mf">0.000001</span><span class="p">)</span>
<span class="go">1.4142136573791504</span>
</pre></div>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Seznam Vsebine</a></h3>
  <ul>
<li><a class="reference internal" href="#">Rekurzija</a><ul>
<li><a class="reference internal" href="#rekurzivni-klici">Rekurzivni klici</a></li>
<li><a class="reference internal" href="#evklidov-algoritem">Evklidov algoritem</a></li>
<li><a class="reference internal" href="#iskanje-nicel-z-bisekcijo">Iskanje ničel z bisekcijo</a></li>
<li><a class="reference internal" href="#neobvezni-argumenti">Neobvezni argumenti</a></li>
<li><a class="reference internal" href="#funkcije-visjega-reda">Funkcije višjega reda</a></li>
</ul>
</li>
</ul>
<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
      <li>Previous: <a href="03-funkcije.html" title="prejšnje poglavje">Funkcije</a></li>
  </ul></li>
</ul>
</div>
  <div role="note" aria-label="source link">
    <h3>Trenutna stran</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/04-rekurzija.txt"
            rel="nofollow">Prikaži izvorno kodo</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Hitro iskanje</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Potrdi" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Vnesi ime modula, razreda ali funkcije.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2016, Matija Pretnar.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.3.5</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.7</a>
      
      |
      <a href="_sources/04-rekurzija.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>