Osnovni tipi
============

Vsaka vrednost v Pythonu ima svoj *tip* oziroma *razred* (ti dve besedi sta
včasih v Pythonu imeli različna pomena, zdaj pa pomenita isto reč), ki opisuje
njene osnovne lastnosti.

Tipi števil ``int`` in ``float``
--------------------------------

Videli smo že, da zna Python računati tako s celimi števil kot s števili s
plavajočo vejico. Prva pripadajo tipu ``int`` (*integer*), druga pa tipu
``float`` (*floating point number*). Razlika med njimi je vidna že na pogled,
saj se druga prikazujejo z decimalno piko. Če želimo, lahko tip ugotovimo tudi
s funkcijo ``type``:

.. doctest::

    >>> type(3)
    <class 'int'>
    >>> type(3.14)
    <class 'float'>
    >>> type(3.0)
    <class 'float'>
    >>> type(10 // 2)
    <class 'int'>
    >>> type(10 / 2)
    <class 'float'>

Število, v katerem uporabimo decimalno piko, je tipa ``float`` tudi takrat,
ko so vse decimalke enake nič. Če računamo s celimi števili, vedno uporabljamo
vrednosti tipa ``int``, saj pri tipu ``float`` prihaja do zaokrožitvenih napak:

.. doctest::

    >>> 7.0 ** 360 / 7.0 ** 342
    1628413597910448.8
    >>> 7 ** 18
    1628413597910449

Pri zgornjem primeru smo res uporabili zelo velika števila, da smo dobili majhno
napako, vendar je to zaradi tega, da smo imeli enostaven primer. Običajni
izračuni so daljši, zato se tudi napake začnejo hitreje nabirati.


Pretvorbe med tipi
------------------

V zgornjih računih vidimo, da Python števila avtomatično pretvori na skupni
imenovalec. Na primer, če število tipa ``int`` pomnožimo s številom tipa
``float``, bo končni rezultat vedno ``float``:

.. doctest::

    >>> 2 * 3.0
    6.0

Pretvorbo lahko opravimo tudi sami s pomočjo funkcij ``int`` in ``float``:

.. doctest::

    >>> float(2)
    2.0
    >>> int(3.1415)
    3

Funkcijo ``int`` bomo pogosto uporabili za to, da danemu število s plavajočo
vejico odbijemo decimalke in ga s tem pretvorimo v celo število. Pozor, ta
funkcija niti ne zaokroži na najbližje celo število, niti ne zaokroži:


.. doctest::

    >>> int(3.999)
    3
    >>> int(-3.1)
    -3
    >>> int(-3.9999)
    -3


Tip kompleksnih števil ``complex``
----------------------------------

Python pozna tudi kompleksna števila tipa ``complex``, ki jih pišemo tako, da
za vrednostjo imaginarnega dela napišemo črko ``j`` (črko ``i`` v programiranju
raje uporabljamo za indekse). Običajno tudi ``+`` med realnim in imaginarnim
delom pišemo brez presledka:

.. doctest::

    >>> 2 + 3j
    (2+3j)
    >>> (1 + 1j) * (1 - 1j)
    (2+0j)
    >>> (-1 + 0j) ** 0.5
    (6.123233995736766e-17+1j)
    >>> 2.718281828459045 ** 3.141592653589793j + 1
    1.2246467991473532e-16j

V zadnjih dveh primerih vidimo, da tudi pri kompleksnih številih prihaja do
zaokrožitvenih napak (prva vrednost bi morala biti ``1j``, druga pa ``1+0j``),
saj Python kompleksna števila predstavi s parom števil s plavajočo vejico. Tako
kot pri tipu ``float`` tudi pri kompleksnih številih Python vse ostale vrednosti
v računu, v katerem se pojavi kakšno kompleksno število, pretvori v tip
``complex``. Tako kot deljenje ``/``, ki dve celi števili pretvori v ``float``,
tudi potenciranje na negativnego število samodejno ustvari kompleksna števila:

.. doctest::

    >>> (-1) ** 0.5
    (6.123233995736766e-17+1j)    

Kompleksna števila lahko ustvarimo tudi s funkcijo ``complex``, ki ji lahko
podamo tudi dva argumenta, da povemo obe komponenti:


.. doctest::

    >>> complex(3)
    (3+0j)
    >>> complex(3, 4)
    (3+4j)

Tip nizov ``str``
-----------------

V programih seveda ne delamo le s števili, temveč tudi z drugimi podatki, na
primer besedili. V ta namen Python podpira tip nizov ``str`` (*string*), ki
so strnjena zaporedja znakov. Običajno jih pišemo v enojnih narekovajih,
na primer ``'to je primer niza'`` ali pa ``'Mama je rekla: "Dober dan!"'.
Nize lahko pišemo tudi z dvojnimi narekovaji, ki jih ponavadi uporabimo takrat,
kadar v nizu želimo uporabiti enojni narekovaj: ``"U Lublan' pr' Šestic'".
V tem primeru niza ne moremo pisati med enojnimi narekovaji, saj bi Python po
narekovaju za ``Lublan`` mislil, da je konec niza.

Včasih želimo uporabiti obe vrsti narekovajev. V tem primeru si pomagamo z
*ubežnimi znaki*. To so znaki, ki jih na običajni način ne moremo zapisati, zato
uporabimo poseben zapis, ki se začne z znakom ``\``. Tedaj lahko pišemo ``'Mama
je iznenada začela peti: "U Lublan\' pr\' Šestic\'…"'`` ali pa ``"Mama je
iznenada začela peti: \"U Lublan' pr' Šestic'…\""``. Ubežne znake brez težav
lahko pišemo tudi tedaj, kadar ni treba ``'Mama je rekla: \"Dober dan!\"'``. Z
ubežnimi znaki lahko zapišemo tudi znak za novo vrstico ``\n``, za tabulator
``\t`` in seveda tudi za poševnico ``\\``, saj je ne moremo pisati le kot ``\``,
ker bi Python to razumel kot začetek ubežnega znaka.

Nize lahko pišemo tudi med tri enojne (``'''```) ali tri dvojne (``"""``)
narekovaje. V tem primeru za en sam narekovaj ne potrebujemo ubežnega znaka.
Take nize lahko pišemo tudi čez več vrstic.

Nize lahko stikamo z operacijo ``+`` in množimo s celimi števili:

.. doctest::

    >>> 'Dober' + 'dan'
    'Doberdan'
    >>> 10 * 'ha'
    'hahahahahahahahahaha'
    >>> 'tro' + 5 * 'lo'
    'trolololololo'

Do posameznega znaka v nizu pridemo z *indeksiranjem*. Z izrazom ``niz[i]``
dostopamo do ``i``-tega znaka v danem nizu:

.. doctest::

    >>> najboljsi_predmet = 'Uvod v programiranje'
    >>> najboljsi_predmet[0]
    'U'
    >>> najboljsi_predmet[7]
    'p'
    >>> najboljsi_predmet[-1]
    'e'
    >>> najboljsi_predmet[-5]
    'r'

Indeksi se začnejo šteti z 0. Če uporabimo negativna števila, lahko štejemo tudi
od zadaj, vendar tam začnemo šteti z -1 (saj je -0 = 0). Na podoben način lahko
dostopamo tudi do podnizov. Če napišemo ``niz[i:j]`` bomo dobili niz od vključno
``i``-tega do vključno ``j - 1``-tega znaka. Če kakšno od meja izpustimo, bomo
vzeli vse znake od začetka oziroma do konca. Pišemo lahko tudi ``niz[i:j:k]``, s
čimer vzamemo le vsak ``k``-ti znak:

.. doctest::

    >>> najboljsi_predmet[10:14]
    'gram'
    >>> najboljsi_predmet[7:]
    'programiranje'
    >>> najboljsi_predmet[5:15:2]
    'vporm'
    >>> najboljsi_predmet[7::3]
    'pgmae'
    >>> najboljsi_predmet[::-1]
    'ejnarimargorp v dovU'

Druge vrednosti lahko pretvorimo v nize s pomočjo funkcije ``str``:

.. doctest::

    >>> str(1234)
    '1234'
    >>> str(1 / 3)
    '0.3333333333333333'
    >>> str(2 < 3)
    'True'

Pretvorbe lahko naredimo tudi v drugo smer, če le napišemo ustrezen niz:

.. doctest::

    >>> int('123')
    123
    >>> float('3.14')
    3.14
    >>> int('12 + 34')
    Traceback (most recent call last):
      ...
    ValueError: invalid literal for int() with base 10: '12 + 34'

Zadnja napaka pravi, da niz ``12 + 34`` ni veljaven zapis celega števila v
desetiškem sistemu.

Tip ničelne vrednosti ``NoneType``
----------------------------------

Tudi vrednost ``None``, ki smo jo srečali takrat, kadar smo v funkciji pozabili
napisati ``return``, ima svoj tip, ki mu rečemo ``NoneType``. Zdaj lahko tudi
razumemo napako, ki smo jo dobili, ko smo ``None`` želeli uporabiti v računu:


.. testcode::

    def f(x):
        x + 1

.. doctest::

    >>> 3 * f(2)
    Traceback (most recent call last):
      ...
    TypeError: unsupported operand type(s) for *: 'int' and 'NoneType'

Napaka ``TypeError`` nam pravi, da smo nekje zamešali tipe. V tem primeru smo z
operacijo ``*`` poskušali pomnožiti ``int`` in ``NoneType``, torej neko celo
število in vrednost ``None`` (saj je to edina vrednost tipa ``NoneType``).
Rezultat klica ``f(2)`` je torej ``None``, zato smo verjetno pozabili na
``return``.

Tip logičnih vrednosti ``bool``
-------------------------------

Logični vrednosti ``True`` in ``False``, ki sta tipa ``bool`` (*boolean*
oz. Booleovi števili) že poznamo. Pretvorbe v logične vrednosti so malo bolj
posebne: vsa neničelna števila in vsi neprazni nizi se pretvorijo v ``True``,
ničla in prazen niz pa v ``False``.

    >>> bool(4)
    True
    >>> bool(0)
    False
    >>> bool(0.00000001)
    True
    >>> bool('False')
    True
    >>> bool('')
    False

Tudi v drugo smer so pretvorbe malo posebne: ``True`` se pretvori v število 1
ali pa niz ``'True'``, ``False`` pa v število 0 oziroma niz ``'False'``.

    >>> int(True)
    1
    >>> float(False)
    0.0
    >>> str(False)
    'False'
    >>> bool(str(False))
    True

Pretvorbe v logične vrednosti v logičnih operacijah in pogojnih stavkih se
izvajajo avtomatično:


.. testcode::

    


Tip tipov ``type``
------------------

