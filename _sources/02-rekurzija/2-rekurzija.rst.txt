Rekurzija
=========

Rekurzivni klici
----------------

Videli smo, da lahko iz funkcij kličemo tudi druge funkcije. Na primer, v funkciji ``povrsina_tetraedra`` smo poklicali funkcijo ``ploscina_trikotnika``, v tej pa vgrajeno funkcijo ``math.sqrt``. V resnici pa lahko v funkciji pokličemo tudi funkcijo samo. Takemu klicu pravimo **rekurzivni klic**. Poglejmo, kako bi izračunali :math:`n! = n \cdot (n - 1) \dots 3 \cdot 2 \cdot 1`. Kot vidimo velja :math:`n! = n \cdot (n - 1)!`, zato bomo :math:`n!` izračunali tako, da bomo :math:`n` pomnožili z :math:`(n - 1)!`. Toda od kod bomo dobili tega? Preprosto, :math:`n - 1` bomo pomnožili z :math:`(n - 2)!`. Od kod pa tega? Ja iz :math:`(n - 3)!`. In tako naprej vse do :math:`2!`, ki ga bomo dobili iz :math:`1!`, tega pa iz :math:`0!`, ki je po definiciji enak :math:`1`.

Torej lahko funkcijo, ki računa fakulteto, napišemo tako, da najprej pogleda svoj argument ``n``. Če je enak 1, vrne 1, sicer pa izračunamo tako, da ``n`` pomnožimo z rezultatom klica ``fakulteta(n - 1)``:

.. testcode::

    def fakulteta(n):
        '''Vrne fakulteto naravnega števila n.'''
        if n == 0:
            return 1
        else:
            return n * fakulteta(n - 1)

.. doctest::

    >>> fakulteta(1)
    1
    >>> fakulteta(5)
    120
    >>> fakulteta(10)
    3628800

Še en primer rekurzivne definicije so Fibonaccijeva števila. Velja :math:`F_0 = 0`, :math:`F_1 = 1`, za vse :math:`n \ge 2` pa velja in :math:`F_{n} = F_{n - 1} + F_{n - 2}`. Funkcijo tedaj napišemo podobno na podoben način kot zgornjo: če je ``n`` enak 0, vrnemo 0, sicer pogledamo, ali je enak 1. V tem primeru vrnemo 1. Če pa tudi 1 ni enak, mora biti večji ali enak 2, zato se pokličemo rekurzivno.

.. testcode::

    def fibonacci(n):
        '''Vrne n-to Fibonaccijevo število.'''
        if n == 0:
            return 0
        elif n == 1:
            return 1
        else:
            return fibonacci(n - 1) + fibonacci(n - 2)

.. doctest::

    >>> fibonacci(3)
    2
    >>> fibonacci(4)
    3
    >>> fibonacci(5)
    5
    >>> fibonacci(20)
    6765

Kaj se zgodi, če poskušate izračunati ``fibonacci(35)``? Po nekaj časa res dobite pravilen odgovor 9227465, vendar to kaže, da nekaj ni v redu. Kmalu bomo videli razloge, zakaj ta funkcija ni dobro napisana. Bolje bi bilo, če bi jo zastavili malo drugače. Poleg Fibonaccijevega zaporedja, ki se začne s številoma 0 in 1, obstaja tudi splošno Fibonaccijevo zaporedje, ki se začne s poljubnima členoma :math:`a` in :math:`b`:

.. math::

    a, b, a + b, b + (a + b) = a + 2 b, (a + b) + (a + 2 b) = 2 a + 3 b, \ldots

Vidimo, da je :math:`n`. člen tega zaporedja ravno :math:`n - 1`. člen zaporedja, ki se začne s členoma :math:`b` in :math:`a + b`. Tedaj lahko definiramo:

.. testcode::

    def splosni_fibonacci(n, a, b):
        '''Vrne n-ti člen Fibonaccijevega zaporedja, ki se začne z a in b.'''
        if n == 0:
            return a
        elif n == 1:
            return b
        else:
            return splosni_fibonacci(n - 1, b, a + b)

Kot lahko sami preizkusimo, ta funkcija deluje veliko hitreje od prejšnje:

.. doctest::

    >>> splosni_fibonacci(35, 0, 1)
    9227465
    >>> splosni_fibonacci(25, 1, -1)
    -28657
    >>> splosni_fibonacci(25, 0, 2)
    150050
    >>> splosni_fibonacci(500, 0, 1)
    139423224561697880139724382870407283950070256587697307264108962948325571622863290691557658876222521294125

Pomembno ni torej samo to, da naš program pravilno izračuna iskani rezultat, temveč tudi to, kako učinkovito ga izračuna.
